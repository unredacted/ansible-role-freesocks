# tasks/main.yml - Main task file that includes other task files

# ============================================================================
# VALIDATION: Vault Decryption Check
# ============================================================================
- name: Fail if vault-encrypted variables are not decrypted
  fail:
    msg: |
      Vault-encrypted variables detected but not decrypted!
      Please run the playbook with --ask-vault-pass or configure vault password file.
      Example: ansible-playbook playbook.yml --ask-vault-pass --extra-vars "..."
  when: >
    (cloudflare_api_token is defined and cloudflare_api_token is string and 
     '$ANSIBLE_VAULT;' in cloudflare_api_token)

# ============================================================================
# VALIDATION: Operation Mode
# ============================================================================
- name: Fail if operation mode is not specified
  fail:
    msg: "Operation mode must be explicitly set to 'deploy', 'migrate', 'change', or 'update'"
  when: operation_mode is not defined or operation_mode == ""

- name: Fail if operation mode is invalid
  fail:
    msg: "Operation mode must be 'deploy', 'migrate', 'change', or 'update', got: {{ operation_mode }}"
  when: operation_mode is defined and operation_mode not in ['deploy', 'migrate', 'change', 'update']

# ============================================================================
# VALIDATION: Environment Mode
# ============================================================================
- name: Fail if environment mode is not specified
  fail:
    msg: "Environment mode must be explicitly set to either 'prod' or 'dev' via --extra-vars"
  when: environment_mode is not defined or environment_mode == ""

- name: Fail if environment mode is invalid
  fail:
    msg: "Environment mode must be either 'prod' or 'dev', got: {{ environment_mode }}"
  when: environment_mode is defined and environment_mode not in ['prod', 'dev']

# ============================================================================
# VALIDATION: Provider Configuration
# ============================================================================
# Note: For change, deploy, and update modes, dns_provider and tunnel_provider are derived from domain_providers
- name: Fail if dns_provider is not specified
  fail:
    msg: "dns_provider must be explicitly set (e.g., 'cloudflare')"
  when:
    - operation_mode not in ['change', 'deploy', 'update']
    - dns_provider is not defined or dns_provider == ""

- name: Fail if dns_provider is invalid
  fail:
    msg: "dns_provider must be 'cloudflare', got: {{ dns_provider }}"
  when:
    - operation_mode not in ['change', 'deploy', 'update']
    - dns_provider is defined
    - dns_provider not in ['cloudflare']

- name: Fail if tunnel_provider is not specified
  fail:
    msg: "tunnel_provider must be explicitly set (e.g., 'cloudflare' or 'none')"
  when:
    - operation_mode not in ['change', 'deploy', 'update']
    - tunnel_provider is not defined or tunnel_provider == ""

- name: Fail if tunnel_provider is invalid
  fail:
    msg: "tunnel_provider must be 'cloudflare' or 'none', got: {{ tunnel_provider }}"
  when:
    - operation_mode not in ['change', 'deploy', 'update']
    - tunnel_provider is defined
    - tunnel_provider not in ['cloudflare', 'none']

- name: Fail if kv_provider is not specified
  fail:
    msg: "kv_provider must be explicitly set (e.g., 'cloudflare')"
  when: kv_provider is not defined or kv_provider == ""

- name: Fail if kv_provider is invalid
  fail:
    msg: "kv_provider must be 'cloudflare', got: {{ kv_provider }}"
  when: kv_provider not in ['cloudflare']

# ============================================================================
# VALIDATION: Deploy Mode (New)
# ============================================================================
- name: Fail if deploy_target_domain is not provided (Deploy Mode)
  fail:
    msg: |
      deploy_target_domain is required for deploy mode.
      Please provide the target domain via --extra-vars.
      Example: --extra-vars "deploy_target_domain=example.app"
  when: 
    - operation_mode == 'deploy'
    - deploy_target_domain is not defined or deploy_target_domain == ''

- name: Fail if domain_providers is not configured (Deploy Mode)
  fail:
    msg: "domain_providers mapping is required for deploy mode."
  when: 
    - operation_mode == 'deploy'
    - (domain_providers is not defined or domain_providers | length == 0)

- name: Fail if target domain not found in domain_providers (Deploy Mode)
  fail:
    msg: |
      Domain '{{ deploy_target_domain }}' not found in domain_providers mapping.
      Available domains: {{ domain_providers.keys() | list | join(', ') }}
  when: 
    - operation_mode == 'deploy'
    - deploy_target_domain not in domain_providers

# ============================================================================
# SETUP: Deploy Mode Configuration
# ============================================================================
- name: Set provider configuration for deploy target domain
  set_fact:
    target_domain_config: "{{ domain_providers[deploy_target_domain] }}"
    effective_dns_provider: "{{ domain_providers[deploy_target_domain].dns_provider }}"
    effective_tunnel_provider: "{{ domain_providers[deploy_target_domain].tunnel_provider | default('none') }}"
    effective_zone_id: "{{ domain_providers[deploy_target_domain].zone_id }}"
    # Override global variables for this deployment
    base_domain: "{{ deploy_target_domain }}"
    api_domain: "{{ deploy_target_domain }}"
    prom_domain: "{{ deploy_target_domain }}"
    cloudflare_zone_id: "{{ domain_providers[deploy_target_domain].zone_id }}"
  when: operation_mode == 'deploy'

# ============================================================================
# KV NAMESPACE SETUP (provider-specific)
# ============================================================================
- name: Set effective KV namespaces based on environment mode (Cloudflare)
  set_fact:
    cloudflare_api_kv_namespace: "{{ cloudflare_api_kv_namespace_dev if environment_mode == 'dev' else cloudflare_api_kv_namespace_prod }}"
    cloudflare_prom_kv_namespace: "{{ cloudflare_prom_kv_namespace_dev if environment_mode == 'dev' else cloudflare_prom_kv_namespace_prod }}"
  when: kv_provider == 'cloudflare'

- name: Fail if Cloudflare KV namespaces are not configured
  fail:
    msg: "KV namespaces must be configured. Set cloudflare_api_kv_namespace_{{ environment_mode }} and cloudflare_prom_kv_namespace_{{ environment_mode }}"
  when: 
    - kv_provider == 'cloudflare'
    - cloudflare_api_kv_namespace is not defined or cloudflare_api_kv_namespace == "" or cloudflare_prom_kv_namespace is not defined or cloudflare_prom_kv_namespace == ""

# ============================================================================
# VALIDATION & SETUP: Change Mode
# ============================================================================
- name: Fail if change_target_domain is not provided (Change Mode)
  fail:
    msg: |
      change_target_domain is required for change mode.
      Please provide the target domain via --extra-vars.
      Example: --extra-vars "change_target_domain=example.app"
  when: 
    - operation_mode == 'change'
    - change_target_domain is not defined or change_target_domain == ''

- name: Fail if domain_providers is not configured (Change Mode)
  fail:
    msg: |
      domain_providers mapping is required for change mode.
      Please configure domain_providers in your playbook with provider settings for each domain.
  when: 
    - operation_mode == 'change'
    - (domain_providers is not defined or domain_providers | length == 0)

- name: Fail if target domain not found in domain_providers (Change Mode)
  fail:
    msg: |
      Domain '{{ change_target_domain }}' not found in domain_providers mapping.
      Available domains: {{ domain_providers.keys() | list | join(', ') }}
  when: 
    - operation_mode == 'change'
    - change_target_domain not in domain_providers

- name: Set provider configuration for change target domain
  set_fact:
    target_domain_config: "{{ domain_providers[change_target_domain] }}"
    effective_dns_provider: "{{ domain_providers[change_target_domain].dns_provider }}"
    effective_tunnel_provider: "{{ domain_providers[change_target_domain].tunnel_provider | default('none') }}"
    effective_zone_id: "{{ domain_providers[change_target_domain].zone_id }}"
  when: operation_mode == 'change'

- name: Debug configuration
  debug:
    msg:
      - "Operation Mode: {{ operation_mode }}"
      - "Environment Mode: {{ environment_mode }}"
      - "DNS Provider: {{ effective_dns_provider | default(dns_provider) | default('pending') }}"
      - "Tunnel Provider: {{ effective_tunnel_provider | default(tunnel_provider) | default('pending') }}"
      - "KV Provider: {{ kv_provider }}"
      - "API KV Namespace: {{ cloudflare_api_kv_namespace | default('N/A') }}"
      - "Prom KV Namespace: {{ cloudflare_prom_kv_namespace | default('N/A') }}"
      - "Deploy Target Domain: {{ deploy_target_domain | default('N/A') }}"
  when: operation_mode != 'update'  # Update mode sets these later

# ============================================================================
# DEPLOY MODE
# ============================================================================
# Component-based deployment: can deploy Outline, slipstream, or both
- name: Deploy server with selected components
  block:
    # Validate component selection
    - name: Fail if no components selected
      fail:
        msg: |
          No components selected for deployment!
          Set at least one of: outline_enabled=true, slipstream_enabled=true
      when:
        - not (outline_enabled | default(true) | bool)
        - not (slipstream_enabled | default(false) | bool)

    - name: Validate slipstream configuration
      fail:
        msg: |
          Invalid slipstream configuration: slipstream_mode=shadowsocks requires outline_enabled=true.
          Either set outline_enabled=true or use slipstream_mode=raw.
      when:
        - slipstream_enabled | default(false) | bool
        - slipstream_mode | default('shadowsocks') == 'shadowsocks'
        - not (outline_enabled | default(true) | bool)

    # Check for existing installation
    - name: Check if /opt/outline already exists
      stat:
        path: /opt/outline
      register: outline_path

    - name: Fail if /opt/outline already exists when deploying Outline
      fail:
        msg: "Cannot deploy Outline: /opt/outline already exists. Please remove it first or use migration mode."
      when:
        - outline_enabled | default(true) | bool
        - outline_path.stat.exists

    # Generate hostname
    - name: Install wamerican package for word list
      apt:
        name: wamerican
        state: present
      when: custom_hostname is not defined

    - name: Get random words from system dictionary
      shell: 'grep "^[a-z]\{3,8\}$" /usr/share/dict/words | tr "[:upper:]" "[:lower:]" | shuf -n {{ hostname_word_count }}'
      register: random_words
      when: custom_hostname is not defined

    - name: Set random hostname from dictionary words
      set_fact:
        random_hostname: "{{ random_words.stdout_lines | join('-') }}"
      when: 
        - random_hostname is not defined
        - custom_hostname is not defined

    - name: Set random hostname from custom override
      set_fact:
        random_hostname: "{{ custom_hostname }}"
      when: 
        - random_hostname is not defined
        - custom_hostname is defined

    - name: Set DNS hostname
      set_fact:
        dns_hostname: "{{ random_hostname }}.{{ base_domain }}"
      when: dns_hostname is not defined

    - name: Set KV store hostname
      set_fact:
        kv_hostname: "{{ random_hostname }}"
      when: kv_hostname is not defined

    - name: Debug deployment configuration
      debug:
        msg:
          - "Random Hostname: {{ random_hostname }}"
          - "DNS Hostname: {{ dns_hostname }}"
          - "KV Hostname: {{ kv_hostname }}"
          - "Components:"
          - "  - Outline: {{ outline_enabled | default(true) | bool }}"
          - "  - slipstream: {{ slipstream_enabled | default(false) | bool }} (mode: {{ slipstream_mode | default('shadowsocks') }})"
          - "  - WebSocket: {{ outline_wss_enabled | default(false) | bool }}"

    # Provider-specific installation (tunnel setup)
    - name: Include Cloudflare installation tasks
      include_tasks: providers/cloudflare/install.yml
      when: effective_tunnel_provider == 'cloudflare'

    # Base installation (common packages)
    - name: Include base installation tasks
      include_tasks: setup/install.yml

    # =========================================================================
    # COMPONENT: Outline Shadowsocks Server
    # =========================================================================
    - name: Install Outline server component
      block:
        - name: Include Outline server tasks
          include_tasks: setup/outline.yml

        - name: Debug Outline installation success
          debug:
            msg: "Outline installation success: {{ outline_install_success }}"
      when: outline_enabled | default(true) | bool

    - name: Set outline_install_success for non-Outline deployments
      set_fact:
        outline_install_success: true
      when: not (outline_enabled | default(true) | bool)

    # Provider-specific DNS setup
    - name: Include DNS tasks (Cloudflare)
      include_tasks: providers/cloudflare/dns.yml
      when: 
        - outline_install_success | bool
        - effective_dns_provider == 'cloudflare'

    # Provider-specific tunnel setup
    - name: Include tunnel tasks (Cloudflare)
      include_tasks: providers/cloudflare/tunnel.yml
      when: 
        - outline_install_success | bool
        - effective_tunnel_provider == 'cloudflare'

    # =========================================================================
    # COMPONENT: WebSocket (requires Outline)
    # =========================================================================
    - name: Include WebSocket configuration tasks
      include_tasks: setup/websocket.yml
      when:
        - outline_install_success | bool
        - outline_enabled | default(true) | bool
        - outline_wss_enabled | default(false) | bool

    # =========================================================================
    # COMPONENT: slipstream DNS Tunnel
    # =========================================================================
    - name: Install slipstream DNS tunnel component
      include_tasks: setup/slipstream.yml
      when:
        - outline_install_success | bool
        - slipstream_enabled | default(false) | bool

    # Provider-specific KV store setup
    - name: Include KV store tasks (Cloudflare)
      include_tasks: providers/cloudflare/kv.yml
      when: 
        - outline_install_success | bool
        - kv_provider == 'cloudflare'

    - name: Display deployment summary
      debug:
        msg: |
          Deployment complete!
          
          Hostname: {{ dns_hostname }}
          
          Components deployed:
          {% if outline_enabled | default(true) | bool %}
            ✓ Outline Shadowsocks server
          {% endif %}
          {% if outline_wss_enabled | default(false) | bool %}
            ✓ WebSocket transport (WSS)
          {% endif %}
          {% if slipstream_enabled | default(false) | bool %}
            ✓ slipstream DNS tunnel ({{ slipstream_mode | default('shadowsocks') }} mode)
          {% endif %}
  when: operation_mode == 'deploy'

# ============================================================================
# MIGRATE MODE
# ============================================================================
- name: Migrate existing Outline server
  block:
    - name: Verify required migration variables
      fail:
        msg: "Migration requires source_hostname, source_kv_hostname, destination_hostname, and destination_kv_hostname to be set"
      when: >
        source_hostname is not defined or 
        source_kv_hostname is not defined or 
        destination_hostname is not defined or 
        destination_kv_hostname is not defined

    - name: Check if /opt/outline already exists
      stat:
        path: /opt/outline
      register: outline_path
      when: inventory_hostname == destination_hostname

    - name: Fail if /opt/outline already exists
      fail:
        msg: "Cannot migrate: /opt/outline already exists on the destination server. Please remove it first."
      when: 
        - inventory_hostname == destination_hostname
        - outline_path.stat.exists | default(false)

    # Provider-specific installation
    - name: Include Cloudflare installation tasks
      include_tasks: providers/cloudflare/install.yml
      when: 
        - inventory_hostname == destination_hostname
        - tunnel_provider == 'cloudflare'

    - name: Include base installation tasks
      include_tasks: setup/install.yml
      when: inventory_hostname == destination_hostname

    - name: Include migration tasks
      include_tasks: migrate/migrate.yml
  when: operation_mode == 'migrate'

# ============================================================================
# CHANGE MODE
# ============================================================================
- name: Change hostname for blocked server
  block:
    - name: Check if /opt/outline exists
      stat:
        path: /opt/outline
      register: outline_path

    - name: Fail if /opt/outline does not exist
      fail:
        msg: "Cannot change hostname: /opt/outline does not exist. This server may not have Outline installed."
      when: not outline_path.stat.exists

    - name: Include change tasks
      include_tasks: change/change.yml
  when: operation_mode == 'change'

# ============================================================================
# UPDATE MODE
# ============================================================================
# Add components (slipstream, WSS) to an existing server
# Does NOT reinstall Outline, only adds new components and updates KV

# Set providers from domain_providers for update mode
# Use slipstream_base_domain if slipstream is enabled, otherwise use base_domain
- name: Set update mode base domain
  set_fact:
    update_base_domain: "{{ slipstream_base_domain if (slipstream_enabled | default(false) | bool) else base_domain }}"
  when: operation_mode == 'update'

- name: Set providers from domain_providers (update mode)
  set_fact:
    dns_provider: "{{ domain_providers[update_base_domain].dns_provider | default('cloudflare') }}"
    tunnel_provider: "{{ domain_providers[update_base_domain].tunnel_provider | default('none') }}"
    base_domain: "{{ update_base_domain }}"
  when:
    - operation_mode == 'update'
    - update_base_domain is defined
    - update_base_domain in domain_providers

- name: Update existing server with new components
  block:
    - name: Check if /opt/outline exists
      stat:
        path: /opt/outline
      register: outline_path

    - name: Set outline_install_success based on existing installation
      set_fact:
        outline_install_success: "{{ outline_path.stat.exists }}"

    - name: Fail if Outline not found for update mode
      fail:
        msg: |
          Update mode requires an existing Outline installation!
          
          Update mode is for adding components to existing servers.
          If you want to deploy slipstream raw mode without Outline, 
          use deploy mode instead:
          
            operation_mode=deploy outline_enabled=false slipstream_enabled=true slipstream_mode=raw
      when: not outline_path.stat.exists

    - name: Fail if Outline not found but slipstream shadowsocks mode requested
      fail:
        msg: |
          Cannot add slipstream in shadowsocks mode: Outline is not installed.
          Either install Outline first or use slipstream_mode=raw.
      when:
        - slipstream_enabled | default(false) | bool
        - slipstream_mode | default('shadowsocks') == 'shadowsocks'
        - not outline_path.stat.exists

    - name: Read existing Outline API info
      slurp:
        src: /opt/outline/access.txt
      register: outline_access_raw
      when: outline_path.stat.exists

    - name: Parse existing API info (key:value format)
      set_fact:
        outline_access_decoded: "{{ outline_access_raw.content | b64decode }}"
      when: outline_path.stat.exists

    - name: Extract API URL from access.txt
      set_fact:
        outline_api_url: "{{ outline_access_decoded | regex_search('apiUrl:(.+)', '\\1') | first }}"
      when: outline_path.stat.exists

    - name: Build outline_api_info object
      set_fact:
        outline_api_info:
          apiUrl: "{{ outline_api_url }}"
          certSha256: "{{ outline_access_decoded | regex_search('certSha256:(.+)', '\\1') | first | default('') }}"
      when: outline_path.stat.exists

    - name: Extract hostname from existing API URL
      set_fact:
        random_hostname: "{{ outline_api_info.apiUrl | regex_search('https://([^.]+)', '\\1') | first }}"
        dns_hostname: "{{ outline_api_info.apiUrl | regex_search('https://([^/]+)', '\\1') | first | regex_replace(':[0-9]+$', '') }}"
      when: outline_path.stat.exists

    # =========================================================================
    # Detect existing components (to avoid re-deploying)
    # =========================================================================
    - name: Check if shadowbox config exists
      stat:
        path: /opt/outline/persisted-state/shadowbox_server_config.json
      register: shadowbox_config_path

    - name: Read shadowbox config to check for WebSocket
      slurp:
        src: /opt/outline/persisted-state/shadowbox_server_config.json
      register: shadowbox_config_raw
      when: shadowbox_config_path.stat.exists

    - name: Set WebSocket already installed flag
      set_fact:
        wss_already_installed: "{{ 'websocketStream' in (shadowbox_config_raw.content | b64decode) }}"
      when: shadowbox_config_path.stat.exists

    - name: Set WebSocket not installed flag
      set_fact:
        wss_already_installed: false
      when: not shadowbox_config_path.stat.exists

    - name: Check if slipstream is already installed
      stat:
        path: /usr/local/bin/slipstream-server
      register: slipstream_installed

    - name: Set slipstream already installed flag
      set_fact:
        slipstream_already_installed: "{{ slipstream_installed.stat.exists }}"

    - name: Debug update configuration
      debug:
        msg:
          - "Update mode: Adding components to existing server"
          - "Detected hostname: {{ random_hostname | default('N/A') }}"
          - "Existing components detected:"
          - "  - WebSocket: {{ wss_already_installed | default(false) }}"
          - "  - slipstream: {{ slipstream_already_installed | default(false) }}"
          - "Components requested:"
          - "  - slipstream: {{ slipstream_enabled | default(false) | bool }} (mode: {{ slipstream_mode | default('shadowsocks') }})"
          - "  - WebSocket: {{ outline_wss_enabled | default(false) | bool }}"
          - "Force reinstall flags:"
          - "  - Force slipstream: {{ force_reinstall_slipstream | default(false) | bool }}"
          - "  - Force WebSocket: {{ force_reinstall_wss | default(false) | bool }}"
          - "Actions:"
          - "  - Install WebSocket: {{ (outline_wss_enabled | default(false) | bool) and (not (wss_already_installed | default(false)) or (force_reinstall_wss | default(false) | bool)) }}"
          - "  - Install slipstream: {{ (slipstream_enabled | default(false) | bool) and (not (slipstream_already_installed | default(false)) or (force_reinstall_slipstream | default(false) | bool)) }}"

    # =========================================================================
    # Track what will be installed
    # =========================================================================
    # Force reinstall flags override the "already installed" detection
    - name: Calculate what will be installed
      set_fact:
        will_install_wss: "{{ (outline_wss_enabled | default(false) | bool) and (not (wss_already_installed | default(false)) or (force_reinstall_wss | default(false) | bool)) }}"
        will_install_slipstream: "{{ (slipstream_enabled | default(false) | bool) and (not (slipstream_already_installed | default(false)) or (force_reinstall_slipstream | default(false) | bool)) }}"

    - name: Check if anything needs to be installed
      set_fact:
        will_install_anything: "{{ will_install_wss or will_install_slipstream }}"

    # =========================================================================
    # Add WebSocket (if enabled AND not already installed)
    # =========================================================================
    - name: Add WebSocket configuration
      include_tasks: setup/websocket.yml
      when:
        - outline_path.stat.exists
        - will_install_wss | bool

    - name: Mark WebSocket as newly installed
      set_fact:
        wss_newly_installed: true
      when: will_install_wss | bool

    # =========================================================================
    # Add slipstream DNS Tunnel (if enabled AND not already installed)
    # =========================================================================
    - name: Add slipstream DNS tunnel
      include_tasks: setup/slipstream.yml
      when:
        - will_install_slipstream | bool

    - name: Mark slipstream as newly installed
      set_fact:
        slipstream_newly_installed: true
      when: will_install_slipstream | bool

    # =========================================================================
    # Update KV store with new component config
    # ONLY if something new was actually installed
    # =========================================================================
    - name: Update KV with new configuration
      block:
        # IMPORTANT: KV namespaces are on the MAIN Cloudflare account, not on
        # per-domain accounts (like slipstream's yandex-ns.com). Never use
        # domain_providers credentials for KV - always use global credentials.
        - name: Set Cloudflare credentials for KV operations
          set_fact:
            cf_token: "{{ kv_cloudflare_api_token | default(cloudflare_api_token) }}"
            cf_account_id: "{{ kv_cloudflare_account_id | default(cloudflare_account_id) }}"

        # For update mode, we need to READ existing KV data and MERGE new config
        - name: Read existing KV data from Cloudflare
          uri:
            url: "{{ cloudflare_api_endpoint }}/accounts/{{ cf_account_id }}/storage/kv/namespaces/{{ cloudflare_api_kv_namespace }}/values/{{ random_hostname }}"
            method: GET
            headers:
              Authorization: "Bearer {{ cf_token }}"
            return_content: yes
            status_code: [200, 404]  # 404 if key doesn't exist yet
          register: existing_kv_data
          delegate_to: localhost

        - name: Debug existing KV response
          debug:
            msg:
              - "KV Read Status: {{ existing_kv_data.status }}"
              - "KV Content Length: {{ existing_kv_data.content | default('') | length }}"
              - "KV Content (first 200 chars): {{ existing_kv_data.content | default('') | truncate(200) }}"


        - name: Parse existing KV data (JSON format)
          set_fact:
            api_endpoint_data: "{{ existing_kv_data.content | from_json }}"
          when:
            - existing_kv_data.status == 200
            - existing_kv_data.content | default('') | length > 0
            - existing_kv_data.content | default('') | trim | first == '{'  # Must start with { to be JSON

        # Handle legacy format: plain URL string (e.g., "https://hostname.domain.com/api/secret")
        # Convert to new JSON format for backwards compatibility
        - name: Migrate legacy KV format (plain URL to JSON)
          set_fact:
            api_endpoint_data:
              apiUrl: "{{ existing_kv_data.content | trim }}"
          when:
            - existing_kv_data.status == 200
            - existing_kv_data.content | default('') | length > 0
            - existing_kv_data.content | default('') | trim | first != '{'  # Not JSON, assume legacy URL
            - api_endpoint_data is not defined

        - name: Debug migrated KV data
          debug:
            msg: "KV data (migrated from legacy): {{ api_endpoint_data }}"
          when:
            - api_endpoint_data is defined
            - existing_kv_data.content | default('') | trim | first != '{'

        - name: Fail if KV entry doesn't exist
          fail:
            msg: |
              Cannot update KV for hostname '{{ random_hostname }}' - entry not found!
              
              This server may not have been deployed with KV storage, or the KV entry was deleted.
              
              To fix this:
              1. Re-deploy the server with operation_mode=deploy
              2. Or manually create the KV entry in Cloudflare
          when:
            - existing_kv_data.status == 404 or (existing_kv_data.content | default('') | length == 0)

        - name: Add websocketDomain to existing data
          set_fact:
            api_endpoint_data: "{{ api_endpoint_data | combine({'websocketDomain': dns_hostname}) }}"
          when:
            - api_endpoint_data is defined
            - wss_newly_installed | default(false) | bool

        - name: Add slipstreamConfig to existing data
          set_fact:
            api_endpoint_data: "{{ api_endpoint_data | combine({'slipstreamConfig': {
              'enabled': true,
              'mode': slipstream_mode | default('shadowsocks'),
              'domain': slipstream_domain,
              'resolver': slipstream_resolver,
              'resolverBackup': slipstream_resolver_backup | default(omit),
              'certPem': slipstream_cert_pem | default(''),
              'socksPort': slipstream_socks_port | default(1080) if slipstream_mode == 'raw' else omit
            }}) }}"
          when:
            - api_endpoint_data is defined
            - slipstream_newly_installed | default(false) | bool
            - slipstream_cert_pem is defined

        - name: Update Cloudflare KV store with merged data
          uri:
            url: "{{ cloudflare_api_endpoint }}/accounts/{{ cf_account_id }}/storage/kv/namespaces/{{ cloudflare_api_kv_namespace }}/values/{{ random_hostname }}"
            method: PUT
            headers:
              Authorization: "Bearer {{ cf_token }}"
              Content-Type: "application/json"
            body: "{{ api_endpoint_data | to_json }}"
            body_format: raw
            status_code: 200
          delegate_to: localhost
          when:
            - api_endpoint_data is defined

        - name: Display update summary (components added)
          debug:
            msg: |
              Update complete!
              
              Server: {{ dns_hostname | default('unknown') }}
              
              Components added:
              {% if wss_newly_installed | default(false) | bool %}
                ✓ WebSocket transport (WSS)
              {% endif %}
              {% if slipstream_newly_installed | default(false) | bool %}
                ✓ slipstream DNS tunnel ({{ slipstream_mode | default('shadowsocks') }} mode)
              {% endif %}
              
              KV store updated with new configuration.
      when:
        - kv_provider == 'cloudflare'
        - random_hostname is defined
        - will_install_anything | bool

    # =========================================================================
    # Nothing to update - show status and exit cleanly
    # =========================================================================
    - name: Display no-op summary
      debug:
        msg: |
          No update needed!
          
          Server: {{ dns_hostname | default('unknown') }}
          
          All requested components are already installed:
          {% if wss_already_installed | default(false) %}
            ✓ WebSocket: already installed
          {% endif %}
          {% if slipstream_already_installed | default(false) %}
            ✓ slipstream: already installed
          {% endif %}
          
          No changes were made.
      when: not (will_install_anything | bool)
  when: operation_mode == 'update'

